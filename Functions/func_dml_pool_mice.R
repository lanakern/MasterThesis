#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#
#### FUNCTION: POOL RESULTS ACROSS MICE DATA FRAMES ####
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#

#+++
# by Lana Kern
#+++
# This function aggregates the treatment effect estimates across the MICE 
# data frames.
#+++
# INPUT:
# -> "dml_result": list result from applying "func_dml"
# -> "N": total number of observations
# -> "mice_num": total number of data frames generated by MICE
#+++
# OUTPUT:
# -> "estimates": aggregated treatment effects, se, etc. across the MICE data sets
# -> "error": mean error metrics across the MICE data sets
#+++

func_dml_pool_mice <- function(dml_result, N, mice_num) {
  
  # store final estimates of each mice data set in one data frame
  dml_final <- data.frame()
  if (is.null(dml_result[[1]]$final)) {
    for (mice_data_sel in 1:mice_num) {
      dml_final <- rbind(
        dml_final,
        dml_result[[mice_data_sel]] %>% mutate(MICE = mice_data_sel) %>%
          select(MICE, everything())
      )
    }
  } else {
    for (mice_data_sel in 1:mice_num) {
      dml_final <- rbind(
        dml_final,
        dml_result[[mice_data_sel]]$final %>% mutate(MICE = mice_data_sel) %>%
          select(MICE, everything())
      )
    }
  }
  
  # do the same for error metrics
  if (!is.null(dml_result[[1]]$error)) {
    dml_error <- data.frame()
    for (mice_data_sel in 1:mice_num) {
      dml_error <- rbind(
        dml_error,
        dml_result[[mice_data_sel]]$error %>% mutate(MICE = mice_data_sel) %>%
          select(MICE, everything())
      )
    }
  }
  
  # do the same for the predictors
  if (!is.null(dml_result[[1]]$predictors)) {
    dml_pred <- data.frame()
    for (mice_data_sel in 1:mice_num) {
      dml_pred <- rbind(
        dml_pred,
        dml_result[[mice_data_sel]]$predictors %>% mutate(MICE = mice_data_sel) %>%
          select(MICE, everything())
      )
    }
  }
  
  # aggregate results across MICE data sets: simply take mean / median of
  # estimates and se
  # For t- and p-value I also take mean / median, but would be identical
  # if I would calculate them again
  # confidence interval is calculated again
  dml_final_estimation <-
    dml_final %>%
    select(Type, starts_with("theta"), starts_with("se"), matches(".*value")) %>%
    group_by(Type) %>%
    summarize(
      theta_mean = mean(theta_mean), theta_median = median(theta_median),
      se_mean = mean(se_mean), se_median = median(se_median),
      tvalue_mean = mean(tvalue_mean), tvalue_median = median(tvalue_median),
      pvalue_mean = mean(pvalue_mean), pvalue_median = median(pvalue_median)
    ) %>%
    mutate(
      # confidence interval
      CI_lower_mean_95 = theta_mean - qt(0.95, df = N - 1)^-1 * (1 - 0.95 / 2) * se_mean / sqrt(N),
      CI_upper_mean_95 = theta_mean + qt(0.95, df = N - 1)^-1 * (1 - 0.95 / 2) * se_mean / sqrt(N),
      CI_lower_median_95 = theta_median - qt(0.95, df = N - 1)^-1 * (1 - 0.95 / 2) * se_median / sqrt(N),
      CI_upper_median_95 = theta_median + qt(0.95, df = N - 1)^-1 * (1 - 0.95 / 2) * se_median / sqrt(N)
    )
  
  if (!is.null(dml_result[[1]]$predictors)) {
    dml_final_estimation <- dml_final_estimation %>%
      mutate(
        # number of predictors
        num_predictors_m = max(dml_pred$num_pred_m), num_predictors_g0 = max(dml_pred$num_pred_g0), 
        num_predictors_g1 = max(dml_pred$num_pred_g1)
      )

  } else {
    dml_final_estimation <- dml_final_estimation
  }
  
  
  # aggregate errors
  if (exists("dml_error")) {
    dml_final_error <- dml_error %>%
      summarize(ACC = mean(ACC), BACC = mean(BACC), AUC = mean(AUC),
                MAE_g0 = mean(MAE_g0), MAE_g1 = mean(MAE_g1),
                MAPE_g0 = mean(MAPE_g0), MAPE_g1 = mean(MAPE_g1),
                MSE_g0 = mean(MSE_g0), MSE_g1 = mean(MSE_g1),
                RMSE_g0 = mean(RMSE_g0), RMSE_g1 = mean(RMSE_g1),
                )
    
    return(list("estimates" = dml_final_estimation, "errors" = dml_final_error))
  } else {
    return(dml_final_estimation)
  }

}